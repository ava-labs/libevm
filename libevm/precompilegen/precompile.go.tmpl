// Package {{.Package}} is a generated package for creating EVM precompiles
// conforming to the EIP-165 interface ID {{interfaceID .ABI}}.
package {{.Package}}

// Code generated by precompilegen. DO NOT EDIT.

import (
    "fmt"
    "math/big"
    "strings"

    "github.com/ava-labs/libevm/accounts/abi"
    "github.com/ava-labs/libevm/common"
    "github.com/ava-labs/libevm/core/vm"
)

// A Contract is an implementation of a precompiled contract conforming to the
// EIP-165 interface ID {{interfaceID .ABI}}.
type Contract interface {
    // Fallback implements a fallback function, called if the method selector
    // fails to match any other method.
    Fallback(vm.PrecompileEnvironment, []byte) ([]byte, error)
{{range methods .ABI}}
    // {{.Name}} implements the function with selector {{hex .ID}}:
    // {{.String}}
    {{signature .}}
{{end}}
}

type methodDispatcher = func(Contract, vm.PrecompileEnvironment, []byte) ([]byte, error)

var (
    // Avoid unused-import errors.
    _ *big.Int = nil
    _ *common.Address = nil

    methods abi.MethodsBySelector
    dispatchers map[abi.Selector]methodDispatcher
)

const abiJSON = `{{.JSON}}`

func init() {
	parsed, err := abi.JSON(strings.NewReader(abiJSON))
	if err != nil {
		panic(err.Error())
	}
    methods = parsed.MethodsBySelector()

    var d dispatch
    dispatchers = map[abi.Selector]methodDispatcher{
        {{range methods .ABI}}{{hex .ID}}: d.{{.Name}},
        {{end}}
    }
}

// New returns a precompiled contract backed by the provided implementation.
func New(impl Contract) vm.PrecompiledContract {
    return vm.NewStatefulPrecompile(precompile{impl}.run)
}

type precompile struct {
    impl Contract
}

const revertBufferWhenNonPayableReceivesValue = "non-payable"

func (p precompile) run(env vm.PrecompileEnvironment, input []byte) ([]byte, error) {
    selector, ok := methods.FindSelector(input)
    if !ok {
        return p.impl.Fallback(env, input)
    }

	switch m := methods[selector]; m.StateMutability {
	case "nonpayable":
		if !env.Value().IsZero() {
			return []byte(revertBufferWhenNonPayableReceivesValue), vm.ErrExecutionReverted
		}
	case "payable":
	case "pure":
		env = env.AsPure()
	case "view":
		env = env.AsReadOnly()
	default:
		// If this happens then `precompilegen` needs to be extended because the
        // Solidity ABI spec changed.
        data := fmt.Sprintf("unsupported state mutability %q on method %s", m.StateMutability, m.Sig)
		return []byte(data), vm.ErrExecutionReverted
	}

    ret, err := dispatchers[selector](p.impl, env, input)
    switch err := err.(type) {
    case nil:
        return ret, nil
    case vm.RevertError:
        return err.Bytes(), vm.ErrExecutionReverted
    default:
        return nil, err
    }
}

// dispatch is the type on which all method dispatchers are defined, stopping
// them from being exported as top-level identifiers that clutter package
// documentation.
type dispatch struct{}

{{range methods .ABI}}
func (dispatch) {{.Name}}(impl Contract, env vm.PrecompileEnvironment, input []byte) ([]byte, error) {
    {{if or (gt (len .Inputs) 0) (gt (len .Outputs) 0) -}}
    method := methods[{{hex .ID}}]
    {{- end}}

    {{if gt (len .Inputs) 0 -}}
    inputs, err := method.Inputs.Unpack(input[abi.SelectorByteLen:])
    if err != nil {
        return nil, err
    }
    {{- range $i, $in := .Inputs}}
    i{{$i}} := inputs[{{$i}}].({{type $in}})
    {{- end}}
    {{- end}}

    {
    {{args "o" (len .Outputs) false true}} := impl.{{.Name}}({{args "i" (len .Inputs) true false}})
    if err != nil {
        return nil, err
    }
    {{if gt (len .Outputs) 0}}
    return method.Outputs.Pack({{args "o" (len .Outputs) false false}})
    {{- else -}}
    return nil, nil
    {{- end}}
    }
}
{{end}}