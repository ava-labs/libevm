// Package testprecompile is a generated package for creating EVM precompiles
// conforming to the EIP-165 interface ID 0xfa0fcd55.
package testprecompile

// Code generated by precompilegen. DO NOT EDIT.

import (
	"math/big"
	"strings"

	"github.com/ava-labs/libevm/accounts/abi"
	"github.com/ava-labs/libevm/common"
	"github.com/ava-labs/libevm/core/vm"
)

// A Contract is an implementation of a precompiled contract conforming to the
// EIP-165 interface ID 0xfa0fcd55.
type Contract interface {
	// Fallback implements a fallback function, called if the method selector
	// fails to match any other method.
	Fallback(vm.PrecompileEnvironment, []byte) ([]byte, uint64, error)

	// Echo implements the function with selector 0x34d6d9be:
	// function Echo(uint256 ) view returns(uint256)
	Echo(vm.PrecompileEnvironment, *big.Int) (*big.Int, error)

	// Echo0 implements the function with selector 0xdb84d7c0:
	// function Echo(string ) view returns(string)
	Echo0(vm.PrecompileEnvironment, string) (string, error)

	// Extract implements the function with selector 0xad8108a4:
	// function Extract((int256) ) view returns(int256)
	Extract(vm.PrecompileEnvironment, struct {
		Val *big.Int "json:\"val\""
	}) (*big.Int, error)

	// HashPacked implements the function with selector 0xd7cc1f37:
	// function HashPacked(uint256 , bytes2 , address ) view returns(bytes32)
	HashPacked(vm.PrecompileEnvironment, *big.Int, [2]uint8, common.Address) ([32]uint8, error)

	// RevertWith implements the function with selector 0xa93cbd97:
	// function RevertWith(bytes ) returns()
	RevertWith(vm.PrecompileEnvironment, []uint8) error

	// Self implements the function with selector 0xc62c692f:
	// function Self() view returns(address)
	Self(vm.PrecompileEnvironment) (common.Address, error)
}

type methodDispatcher = func(Contract, vm.PrecompileEnvironment, []byte) ([]byte, error)

var (
	// Avoid unused-import errors.
	_ *big.Int        = nil
	_ *common.Address = nil

	methods     vm.MethodsBySelector
	dispatchers map[vm.Selector]methodDispatcher
)

const abiJSON = `[{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"Echo","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"","type":"string"}],"name":"Echo","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"components":[{"internalType":"int256","name":"val","type":"int256"}],"internalType":"struct IPrecompile.Wrapper","name":"","type":"tuple"}],"name":"Extract","outputs":[{"internalType":"int256","name":"","type":"int256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"bytes2","name":"","type":"bytes2"},{"internalType":"address","name":"","type":"address"}],"name":"HashPacked","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"","type":"bytes"}],"name":"RevertWith","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"Self","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]`

func init() {
	parsed, err := abi.JSON(strings.NewReader(abiJSON))
	if err != nil {
		panic(err.Error())
	}
	methods = vm.BySelector(parsed.Methods)

	var d dispatch
	dispatchers = map[vm.Selector]methodDispatcher{
		0x34d6d9be: d.Echo,
		0xdb84d7c0: d.Echo0,
		0xad8108a4: d.Extract,
		0xd7cc1f37: d.HashPacked,
		0xa93cbd97: d.RevertWith,
		0xc62c692f: d.Self,
	}
}

// New returns a precompiled contract backed by the provided implementation.
func New(impl Contract) vm.PrecompiledContract {
	return vm.NewStatefulPrecompile(precompile{impl}.run)
}

type precompile struct {
	impl Contract
}

func (p precompile) run(env vm.PrecompileEnvironment, input []byte, suppliedGas uint64) ([]byte, uint64, error) {
	selector, ok := methods.FindSelector(input)
	if !ok {
		return p.impl.Fallback(env, input)
	}
	ret, err := dispatchers[selector](p.impl, env, input)
	switch err := err.(type) {
	case nil:
		return ret, 0, nil
	case vm.RevertError:
		return err.Bytes(), 0, vm.ErrExecutionReverted
	default:
		return nil, 0, err
	}
}

// dispatch is the type on which all method dispatchers are defined, stopping
// them from being exported as top-level identifiers that clutter package
// documentation.
type dispatch struct{}

func (dispatch) Echo(impl Contract, env vm.PrecompileEnvironment, input []byte) ([]byte, error) {
	method := methods[0x34d6d9be]

	inputs, err := method.Inputs.Unpack(input[vm.SelectorByteLen:])
	if err != nil {
		return nil, err
	}
	i0 := inputs[0].(*big.Int)

	{
		o0, err := impl.Echo(env, i0)
		if err != nil {
			return nil, err
		}

		return method.Outputs.Pack(o0)
	}
}

func (dispatch) Echo0(impl Contract, env vm.PrecompileEnvironment, input []byte) ([]byte, error) {
	method := methods[0xdb84d7c0]

	inputs, err := method.Inputs.Unpack(input[vm.SelectorByteLen:])
	if err != nil {
		return nil, err
	}
	i0 := inputs[0].(string)

	{
		o0, err := impl.Echo0(env, i0)
		if err != nil {
			return nil, err
		}

		return method.Outputs.Pack(o0)
	}
}

func (dispatch) Extract(impl Contract, env vm.PrecompileEnvironment, input []byte) ([]byte, error) {
	method := methods[0xad8108a4]

	inputs, err := method.Inputs.Unpack(input[vm.SelectorByteLen:])
	if err != nil {
		return nil, err
	}
	i0 := inputs[0].(struct {
		Val *big.Int "json:\"val\""
	})

	{
		o0, err := impl.Extract(env, i0)
		if err != nil {
			return nil, err
		}

		return method.Outputs.Pack(o0)
	}
}

func (dispatch) HashPacked(impl Contract, env vm.PrecompileEnvironment, input []byte) ([]byte, error) {
	method := methods[0xd7cc1f37]

	inputs, err := method.Inputs.Unpack(input[vm.SelectorByteLen:])
	if err != nil {
		return nil, err
	}
	i0 := inputs[0].(*big.Int)
	i1 := inputs[1].([2]uint8)
	i2 := inputs[2].(common.Address)

	{
		o0, err := impl.HashPacked(env, i0, i1, i2)
		if err != nil {
			return nil, err
		}

		return method.Outputs.Pack(o0)
	}
}

func (dispatch) RevertWith(impl Contract, env vm.PrecompileEnvironment, input []byte) ([]byte, error) {
	method := methods[0xa93cbd97]

	inputs, err := method.Inputs.Unpack(input[vm.SelectorByteLen:])
	if err != nil {
		return nil, err
	}
	i0 := inputs[0].([]uint8)

	{
		err := impl.RevertWith(env, i0)
		if err != nil {
			return nil, err
		}
		return nil, nil

	}
}

func (dispatch) Self(impl Contract, env vm.PrecompileEnvironment, input []byte) ([]byte, error) {
	method := methods[0xc62c692f]

	{
		o0, err := impl.Self(env)
		if err != nil {
			return nil, err
		}

		return method.Outputs.Pack(o0)
	}
}
